import React, { useState, useEffect, useRef } from 'react';
import './App.css';
// import logo from './assets/remi-logo.png'; // Commenting out logo import

function App() {
  const [isRecording, setIsRecording] = useState(false);
  const [userName, setUserName] = useState('');
  const [conversation, setConversation] = useState([]);
  const [greeting, setGreeting] = useState('');
  const [isRemiSpeaking, setIsRemiSpeaking] = useState(false);
  const [remiText, setRemiText] = useState('');
  // const [showSplash, setShowSplash] = useState(true);
  // const [showContent, setShowContent] = useState(false);
  const mediaRecorderRef = useRef(null);
  const audioChunksRef = useRef([]);
  const wsRef = useRef(null);
  const GEMINI_API_KEY = "AIzaSyBIme458y1fI4BdfIr-diMqhGTHZ-j3yC4";

  useEffect(() => {
    // Remove the load event listener and just do initial greeting
    generateGreeting();

    // No need for cleanup since we're not adding event listener
    return () => { };
  }, []);

  const generateGreeting = async () => {
    try {
      // Get the current hour to personalize greeting
      const hour = new Date().getHours();
      const timeOfDay = hour < 12 ? "morning" : hour < 18 ? "afternoon" : "evening";

      // Add more variety to the prompt
      const greetings = [
        "Hello! I'm here to help you preserve your precious memories.",
        `This ${timeOfDay}, let's cherish our special moments together.`,
        `As the ${timeOfDay} unfolds, I'm here to safeguard your treasured memories.`,
        `Wishing you a wonderful ${timeOfDay} filled with cherished memories.`,
        `In this peaceful ${timeOfDay}, let's preserve your precious stories.`,
        `May this ${timeOfDay} bring comfort as we save your special memories.`
      ];

      // Get a random greeting
      const selectedGreeting = greetings[Math.floor(Math.random() * greetings.length)];
      setGreeting(selectedGreeting);

      // Reuse existing WebSocket if it's open, otherwise create new one
      if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {
        wsRef.current = new WebSocket('ws://localhost:8000/ws');
      }

      wsRef.current.onopen = () => {
        wsRef.current.send(JSON.stringify({
          type: 'user_input',
          text: selectedGreeting
        }));
      };

      wsRef.current.onmessage = async (event) => {
        const data = JSON.parse(event.data);
        if (data.type === 'audio') {
          // Convert base64 audio to blob and play it
          const audioData = atob(data.audio_data);
          const arrayBuffer = new ArrayBuffer(audioData.length);
          const uint8Array = new Uint8Array(arrayBuffer);
          for (let i = 0; i < audioData.length; i++) {
            uint8Array[i] = audioData.charCodeAt(i);
          }
          const audioBlob = new Blob([arrayBuffer], { type: 'audio/wav' });
          const audioUrl = URL.createObjectURL(audioBlob);
          const audio = new Audio(audioUrl);
          await audio.play();
          URL.revokeObjectURL(audioUrl);
        }
      };

    } catch (error) {
      console.error('Error generating greeting:', error);
      const fallbackGreeting = "Hello! I'm here to help you preserve your precious memories.";
      setGreeting(fallbackGreeting);

      // Reuse existing WebSocket if it's open, otherwise create new one
      if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {
        wsRef.current = new WebSocket('ws://localhost:8000/ws');
      }

      wsRef.current.onopen = () => {
        wsRef.current.send(JSON.stringify({
          type: 'user_input',
          text: fallbackGreeting
        }));
      };
    }
  };

  useEffect(() => {
    const ws = new WebSocket('ws://localhost:8000/ws');
    wsRef.current = ws;

    ws.onopen = () => {
      console.log('WebSocket connected');
    };

    // Create a function to send messages only when connection is ready
    const sendMessage = async (message) => {
      // Wait for connection to be ready
      while (ws.readyState === WebSocket.CONNECTING) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }

      if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(message));
      }
    };

    // If we don't have a username, send the ask_name message after ensuring connection
    if (!userName) {
      sendMessage({
        type: 'ask_name'
      });
    }

    ws.onmessage = async (event) => {
      const data = JSON.parse(event.data);
      console.log('Received message:', data);

      if (data.type === 'remi_speaking') {
        setIsRemiSpeaking(true);
        setRemiText(data.text);
      } else if (data.type === 'audio') {
        const audio = new Audio(`data:audio/mp3;base64,${data.audio_data}`);
        audio.onended = async () => {
          setIsRemiSpeaking(false);
          setIsRecording(true);

          // Remove any WebSocket close/reconnect logic
          try {
            // Setup audio recording
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorderRef.current = new MediaRecorder(stream, {
              mimeType: 'audio/webm',  // Use webm format which is widely supported
            });
            audioChunksRef.current = [];

            mediaRecorderRef.current.ondataavailable = (event) => {
              if (event.data.size > 0) {
                audioChunksRef.current.push(event.data);
              }
            };

            mediaRecorderRef.current.onstop = async () => {
              const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });  // Match the format
              audioChunksRef.current = [];

              if (!userName) {
                await sendNameToBackend(audioBlob);
              } else {
                await sendAudioToBackend(audioBlob);
              }
            };

            // Start recording
            mediaRecorderRef.current.start(1000);

            // Set a timeout to stop this recording segment after 10 seconds
            setTimeout(() => {
              if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
                mediaRecorderRef.current.stop();
              }
            }, 10000);
          } catch (error) {
            console.error('Error starting recording:', error);
            setIsRecording(false);
          }
        };

        try {
          await audio.play();
        } catch (error) {
          console.log('Audio playback failed:', error);
          audio.onended();
        }
      } else if (data.type === 'name_received') {
        setUserName(data.name);
      }
    };

    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };

    // Remove the cleanup function that closes the connection
  }, []);

  const startRecording = async () => {
    try {
      // Close existing WebSocket if any
      if (wsRef.current) {
        wsRef.current.close();
        wsRef.current = null;
      }

      // Create new WebSocket connection
      const ws = new WebSocket('ws://localhost:8000/ws');
      wsRef.current = ws;

      // Wait for connection to be established
      await new Promise((resolve, reject) => {
        ws.onopen = resolve;
        ws.onerror = reject;
      });

      // Send initial message
      console.log('Sending initial message');
      setIsRemiSpeaking(true);
      ws.send(JSON.stringify({
        type: !userName ? 'ask_name' : 'start_conversation',
        user_name: userName
      }));

    } catch (error) {
      console.error('Error starting conversation:', error);
      setIsRemiSpeaking(false);
    }
  };

  const stopRecording = () => {
    setIsRecording(false);
    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
      mediaRecorderRef.current.stop();
    }
    if (mediaRecorderRef.current) {
      mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());
    }

    // Close the WebSocket connection
    if (wsRef.current) {
      wsRef.current.send(JSON.stringify({
        type: 'end_conversation',
        user_name: userName
      }));
      wsRef.current.close();
      wsRef.current = null;
    }
  };

  const sendAudioToBackend = async (audioBlob) => {
    try {
      const formData = new FormData();
      formData.append('audio', audioBlob);
      formData.append('user_name', userName);

      const response = await fetch('http://localhost:8000/process-audio', {
        method: 'POST',
        body: formData
      });

      if (!response.ok) {
        throw new Error('Failed to process audio');
      }

      const data = await response.json();
      console.log('Transcription:', data.transcription);
      setConversation(prev => [...prev, { type: 'user', text: data.transcription }]);

      if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify({
          type: 'user_input',
          text: data.transcription,
          user_name: userName
        }));
      }
    } catch (error) {
      console.error('Error sending audio to backend:', error);
    }
  };

  const sendNameToBackend = async (audioBlob) => {
    try {
      const formData = new FormData();
      formData.append('audio', audioBlob);

      const response = await fetch('http://localhost:8000/process-name', {
        method: 'POST',
        body: formData
      });

      if (!response.ok) {
        throw new Error('Failed to process name audio');
      }

      const data = await response.json();
      console.log('Name transcription:', data.name);

      // The backend will send the name back through WebSocket
      // which will trigger the name_received handler
    } catch (error) {
      console.error('Error sending name audio to backend:', error);
    }
  };

  return (
    <div className="App">
      {/* {showSplash && (
        <div className={`splash-screen ${!showSplash ? 'fade-out' : ''}`}>
          <img
            src={logo}
            alt="REMI - A friend that remembers"
            className="splash-logo"
          />
        </div>
      )} */}

      <div className="content">
        <button className="daily-check-button">
          DAILY CHECK {'\u{1F9E0}'}
        </button>

        {greeting && <div className="greeting">{greeting}</div>}

        <button
          className={`mic-button ${isRemiSpeaking ? 'remi-speaking' : ''} ${isRecording ? 'recording' : ''}`}
          onClick={isRecording ? stopRecording : startRecording}
        >
          <div className="mic-icon"></div>
        </button>

        <div className="app-name">REMI {'\u{1F9E0}'}</div>
      </div>
    </div>
  );
}

export default App;
